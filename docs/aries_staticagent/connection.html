<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>aries_staticagent.connection API documentation</title>
<meta name="description" content="Static Agent Connection." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aries_staticagent.connection</code></h1>
</header>
<section id="section-intro">
<p>Static Agent Connection.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Static Agent Connection.&#34;&#34;&#34;
import asyncio
from contextlib import contextmanager
import json
from typing import (
    Awaitable,
    Callable,
    Dict,
    List,
    Optional,
    Sequence,
    Set,
    Tuple,
    Union,
)
import uuid

from . import crypto
from .dispatcher import Dispatcher, Handler
from .message import Message, MsgType
from .module import Module
from .utils import ensure_key_bytes, forward_msg, http_send


Send = Callable[[bytes, str], Awaitable[Optional[bytes]]]
SessionSend = Callable[[bytes], Awaitable[None]]
ConditionFutureMap = Dict[Callable[[Message], bool], asyncio.Future]


class MessageDeliveryError(Exception):
    &#34;&#34;&#34;When a message cannot be delivered.&#34;&#34;&#34;

    def __init__(self, *, status: int = None, msg: str = None):
        super().__init__(msg)
        self.status = status


class Session:
    &#34;&#34;&#34;An active transport-layer connection/socket providing a send method.&#34;&#34;&#34;

    THREAD_ALL = &#34;all&#34;

    def __init__(self, conn: &#34;Connection&#34;, send: SessionSend, thread: str = None):
        if send is None:
            raise TypeError(&#34;Must supply send method to Session&#34;)

        if not callable(send) and not asyncio.iscoroutine(send):
            raise TypeError(
                &#34;Invalid send method; expected coroutine or function, got {}&#34;.format(
                    type(send).__name__
                )
            )

        self._id = str(uuid.uuid4())
        self._conn = conn
        self._send = send
        self._thread = thread
        self._status = None

    @property
    def session_id(self):
        &#34;&#34;&#34;Unique Identifier for this session.&#34;&#34;&#34;
        return self._id

    @property
    def thread(self):
        &#34;&#34;&#34;Get this session&#39;s assigned thread.&#34;&#34;&#34;
        return self._thread

    def update_thread_from_msg(self, msg: Message):
        &#34;&#34;&#34;Update a thread with info from the ~transport decorator.&#34;&#34;&#34;
        if &#34;~transport&#34; not in msg and self._thread is None:
            return

        transport = msg[&#34;~transport&#34;]
        if transport[&#34;return_route&#34;] == &#34;all&#34;:
            self._thread = self.THREAD_ALL
            return

        if transport[&#34;return_route&#34;] == &#34;thread&#34;:
            self._thread = transport[&#34;return_route_thread&#34;]
            return

        if transport[&#34;return_route&#34;] == &#34;none&#34;:
            self._thread = None
            return

    def should_return_route(self) -&gt; bool:
        &#34;&#34;&#34;Session set to return route?&#34;&#34;&#34;
        return bool(self._thread)

    def thread_all(self) -&gt; bool:
        &#34;&#34;&#34;Session is set to return all messages.&#34;&#34;&#34;
        return self.thread == self.THREAD_ALL

    async def send(self, message: bytes):
        &#34;&#34;&#34;Send a packed message to this session.&#34;&#34;&#34;
        if not self.should_return_route():
            raise RuntimeError(&#34;Session is not set to return route&#34;)

        ret = self._send(message)
        if asyncio.iscoroutine(ret):
            return await ret

        return ret

    async def handle(self, message: bytes):
        &#34;&#34;&#34;
        Handle a message received over this session.

        Delegates to connection&#39;s handle.
        &#34;&#34;&#34;
        return await self._conn.handle(message, self)

    def __hash__(self):
        return hash(self.session_id)

    def __eq__(self, other):
        if not isinstance(other, Session):
            return False
        return self.session_id == other.session_id


class Keys:
    Key = Union[bytes, str]

    &#34;&#34;&#34;Container for keys with convenience methods.&#34;&#34;&#34;

    class Mixin:
        &#34;&#34;&#34;Mixin for shortcuts to keys.&#34;&#34;&#34;

        def __init__(self, keys: &#34;Keys&#34;):
            self.keys = keys

        @property
        def verkey(self):
            &#34;&#34;&#34;Get verkey.&#34;&#34;&#34;
            return self.keys.verkey

        @property
        def verkey_b58(self):
            &#34;&#34;&#34;Get Base58 encoded verkey.&#34;&#34;&#34;
            return self.keys.verkey_b58

        @property
        def sigkey(self):
            &#34;&#34;&#34;Get sigkey.&#34;&#34;&#34;
            return self.keys.sigkey

        @property
        def did(self):
            &#34;&#34;&#34;Get verkey based DID for this connection.&#34;&#34;&#34;
            return self.keys.did

    def __init__(self, verkey: Key, sigkey: Key):
        self._verkey = ensure_key_bytes(verkey)
        self._sigkey = ensure_key_bytes(sigkey)

    @property
    def verkey(self):
        &#34;&#34;&#34;Get verkey.&#34;&#34;&#34;
        return self._verkey

    @property
    def verkey_b58(self):
        &#34;&#34;&#34;Get Base58 encoded verkey.&#34;&#34;&#34;
        return crypto.bytes_to_b58(self.verkey)

    @property
    def sigkey(self):
        &#34;&#34;&#34;Get sigkey.&#34;&#34;&#34;
        return self._sigkey

    @property
    def did(self):
        &#34;&#34;&#34;Get verkey based DID for this connection.&#34;&#34;&#34;
        return crypto.bytes_to_b58(self._verkey[:16])

    def __str__(self):
        return &#34;Keys({}, {}...)&#34;.format(
            self.verkey_b58, crypto.bytes_to_b58(self.sigkey)[:10]
        )


class Target:
    &#34;&#34;&#34;Container for information about our message destination.&#34;&#34;&#34;

    def __init__(
        self,
        *,
        endpoint: str = None,
        their_vk: Union[bytes, str] = None,
        recipients: Sequence[Union[bytes, str]] = None,
        routing_keys: Sequence[Union[bytes, str]] = None,
    ):
        if their_vk and recipients:
            raise ValueError(&#34;their_vk and recipients are mutually exclusive.&#34;)

        self.endpoint: Optional[str] = endpoint
        self.recipients: Optional[List[bytes]] = None
        self.routing_keys: Optional[List[bytes]] = None

        if their_vk:
            self.recipients = [ensure_key_bytes(their_vk)]

        if recipients:
            self.recipients = list(map(ensure_key_bytes, recipients))

        if routing_keys:
            self.routing_keys = list(map(ensure_key_bytes, routing_keys))

    def update(
        self,
        *,
        endpoint: str = None,
        their_vk: Union[bytes, str] = None,
        recipients: Sequence[Union[bytes, str]] = None,
        routing_keys: Sequence[Union[bytes, str]] = None,
        **_kwargs,
    ):
        &#34;&#34;&#34;Update their information.&#34;&#34;&#34;
        if their_vk and recipients:
            raise ValueError(&#34;their_vk and recipients are mutually exclusive.&#34;)

        if endpoint:
            self.endpoint = endpoint

        if their_vk:
            self.recipients = [ensure_key_bytes(their_vk)]

        if recipients:
            self.recipients = list(map(ensure_key_bytes, recipients))

        if routing_keys:
            self.routing_keys = list(map(ensure_key_bytes, routing_keys))


class Connection(Keys.Mixin):
    &#34;&#34;&#34;Create a Static Agent Connection to another agent.

    The following will create a Static Connection with just the receiving end
    in place. This makes it possible to receive a message over this connection
    without yet knowing where messages will be sent.

    &gt;&gt;&gt; my_keys = crypto.create_keypair()
    &gt;&gt;&gt; connection = Connection.receiver(my_keys)

    To create a Static Agent Connection with both ends configured:
    &gt;&gt;&gt; their_pretend_verkey = crypto.create_keypair()[0]
    &gt;&gt;&gt; connection = Connection.from_parts(
    ...     my_keys, their_vk=their_pretend_verkey
    ... )

    Or, when there are multiple recipients:
    &gt;&gt;&gt; pretend_recips = [ crypto.create_keypair()[0] for i in range(5) ]
    &gt;&gt;&gt; connection = Connection.from_parts(
    ...     my_keys, recipients=pretend_recips
    ... )

    To specify mediators responsible for forwarding messages to the recipient:
    &gt;&gt;&gt; pretend_mediators = [ crypto.create_keypair()[0] for i in range(5) ]
    &gt;&gt;&gt; connection = Connection.from_parts(
    ...     my_keys, their_vk=their_pretend_verkey,
    ...     routing_keys=pretend_mediators
    ... )

    By default, `Connection` will POST messages to the endpoint given
    over HTTP. You can, however, specify an alternative `Send` method for
    `Connection` as in the example below:
    &gt;&gt;&gt; async def my_send(msg: bytes, endpoint: str) -&gt; Optional[bytes]:
    ...     print(&#39;pretending to send message to&#39;, endpoint)
    ...     response = None
    ...     return response
    &gt;&gt;&gt; connection = Connection.from_parts(
    ...     my_keys, their_vk=their_pretend_verkey,
    ...     endpoint=&#39;example.com&#39;, send=my_send
    ... )
    &gt;&gt;&gt; connection.send({&#39;@type&#39;: &#39;doc_uri/protocol/0.1/test&#39;})
    pretending to send message to example.com


    Arguments:

        keys (tuple of bytes or str): A tuple of our public and private key.

    NamedArguments:

        their_vk (bytes or str): Specify &#34;their&#34; verification key for this
            connection. Specifies only one recipient. Mutually exclusive with
            recipients.

        recipients ([bytes or str]): Specify one or more recipients for this
            connection. Mutually exclusive with their_vk.

        routing_keys ([bytes or str]): Specify one or more mediators for this
            connection.

        send (Send): Specify the send method for this connection. See notes
            above for function signature.  Defaults to
            `aries_staticagent.utils.http_send`.

        dispatcher (aries_staticagent.dispatcher.Dispatcher): Specify a
            dispatcher for this connection.  Defaults to
            `aries_staticagent.dispatcher.Dispatcher`.
    &#34;&#34;&#34;

    def __init__(
        self,
        keys: Keys,
        target: Target = None,
        *,
        modules: Sequence[Union[Module, type]] = None,
        send: Send = None,
        dispatcher: Dispatcher = None,
    ):

        Keys.Mixin.__init__(self, keys)
        self.target = target

        if modules:
            for mod in modules:
                if isinstance(mod, type):  # attempt to instantiate module
                    mod = mod()
                self.route_module(mod)

        self._send: Send = send or http_send
        self._dispatcher = dispatcher or Dispatcher()

        self._next: ConditionFutureMap = {}
        self._sessions: Set[Session] = set()

    @classmethod
    def from_parts(
        cls,
        keys: Union[Keys, Tuple[Keys.Key, Keys.Key]],
        *,
        endpoint: str = None,
        their_vk: Union[bytes, str] = None,
        recipients: Sequence[Union[bytes, str]] = None,
        routing_keys: Sequence[Union[bytes, str]] = None,
        **kwargs,
    ):
        &#34;&#34;&#34;Construct a static connection from its parts.

        Arguments:

            keys (tuple of bytes or str): A tuple of our public and private
            key.

        NamedArguments:

            their_vk (bytes or str): Specify &#34;their&#34; verification key for this
                connection. Specifies only one recipient. Mutually exclusive
                with recipients.

            recipients ([bytes or str]): Specify one or more recipients for
                this connection. Mutually exclusive with their_vk.

            routing_keys ([bytes or str]): Specify one or more mediators for
                this connection.

            send (Send): Specify the send method for this connection. See notes
                above for function signature.  Defaults to
                `aries_staticagent.utils.http_send`.

            dispatcher (aries_staticagent.dispatcher.Dispatcher): Specify a
                dispatcher for this connection.  Defaults to
                `aries_staticagent.dispatcher.Dispatcher`.
        &#34;&#34;&#34;
        if not isinstance(keys, Keys):
            keys = Keys(*keys)
        target = None
        if endpoint or their_vk or recipients or routing_keys:
            target = Target(
                endpoint=endpoint,
                their_vk=their_vk,
                recipients=recipients,
                routing_keys=routing_keys,
            )
        return cls(keys, target, **kwargs)

    @classmethod
    def receiver(cls, keys: Union[Keys, Tuple[Keys.Key, Keys.Key]], **kwargs):
        &#34;&#34;&#34;Create a static connection to be used only for receiving messages.

        Arguments:

            keys (Keys or Tuple of keys): Our public and private keys.
        &#34;&#34;&#34;
        if not isinstance(keys, Keys):
            keys = Keys(*keys)
        return cls(keys, **kwargs)

    @classmethod
    def random(cls, target: Target = None, **kwargs):
        &#34;&#34;&#34;Generate connection with random keys.&#34;&#34;&#34;
        return cls(Keys(*crypto.create_keypair()), target, **kwargs)

    @classmethod
    def from_seed(cls, seed: bytes, target: Target = None, **kwargs):
        &#34;&#34;&#34;Generate connection from seed.&#34;&#34;&#34;
        return cls(Keys(*crypto.create_keypair(seed=seed)), target, **kwargs)

    def route(self, msg_type: str) -&gt; Callable:
        &#34;&#34;&#34;Register route decorator.&#34;&#34;&#34;

        def register_route_dec(func):
            self._dispatcher.add_handler(Handler(MsgType(msg_type), func))
            return func

        return register_route_dec

    def route_module(self, module: Module):
        &#34;&#34;&#34;Register a module for routing.&#34;&#34;&#34;
        handlers = [Handler(msg_type, func) for msg_type, func in module.routes.items()]
        return self._dispatcher.add_handlers(handlers)

    def clear_routes(self):
        &#34;&#34;&#34;Clear registered routes.&#34;&#34;&#34;
        return self._dispatcher.clear_handlers()

    async def dispatch(self, message):
        &#34;&#34;&#34;
        Dispatch message to handler.
        &#34;&#34;&#34;
        await self._dispatcher.dispatch(message, self)

    @contextmanager
    def next(self, type_: str = None, condition: Callable[[Message], bool] = None):
        &#34;&#34;&#34;
        Context manager to claim the next message matching condtion, allowing
        temporary bypass of regular dispatch.

        This will consume only the next message matching condition. If you need
        to consume more than one or two, consider using a standard message
        handler or overriding the default dispatching mechanism.
        &#34;&#34;&#34;
        if condition and type_:
            raise ValueError(&#34;Expected type or condtion, not both.&#34;)
        if condition and not callable(condition):
            raise TypeError(&#34;condition must be Callable[[Message], bool]&#34;)

        if not condition and not type_:
            # Collect everything
            def _default(_msg):
                return True

            selected_condition = _default

        if type_:

            def _matches_type(msg):
                return msg.type == type_

            selected_condition = _matches_type

        if condition:
            selected_condition = condition

        next_message: asyncio.Future[Message] = asyncio.Future()
        self._next[selected_condition] = next_message

        yield next_message

        del self._next[selected_condition]

    def unpack(self, packed_message: Union[bytes, dict]) -&gt; Message:
        &#34;&#34;&#34;Unpack a message, filling out metadata in the MTC.&#34;&#34;&#34;
        try:
            (unpacked_msg, sender_vk, recip_vk) = crypto.unpack_message(
                packed_message, self.verkey, self.sigkey
            )
            msg = Message.deserialize(unpacked_msg)
            if sender_vk:
                msg.mtc.set_authcrypted(sender_vk, recip_vk)
            else:
                msg.mtc.set_anoncrypted(recip_vk)

        except (ValueError, KeyError):
            if not isinstance(packed_message, bytes):
                raise TypeError(&#34;Expected bytes, got {}&#34;.format(type(msg).__name__))
            msg = Message.deserialize(packed_message)
            msg.mtc.set_plaintext()

        return msg

    def pack(
        self, msg: Union[dict, Message], anoncrypt=False, plaintext=False
    ) -&gt; bytes:
        &#34;&#34;&#34;Pack a message for sending over the wire.&#34;&#34;&#34;
        if plaintext and anoncrypt:
            raise ValueError(&#34;plaintext and anoncrypt flags are mutually exclusive.&#34;)

        if not isinstance(msg, Message):
            if isinstance(msg, dict):
                msg = Message.parse_obj(msg)
            else:
                raise TypeError(
                    f&#34;msg must be type Message or dict; received {type(msg)}&#34;
                )

        if plaintext:
            return msg.serialize().encode(&#34;ascii&#34;)

        if not self.target or not self.target.recipients:
            raise RuntimeError(&#34;No recipients for whom to pack this message&#34;)

        if anoncrypt:
            packed_message = crypto.pack_message(
                msg.serialize(),
                self.target.recipients,
            )
        else:
            packed_message = crypto.pack_message(
                msg.serialize(),
                self.target.recipients,
                self.verkey,
                self.sigkey,
            )

        if self.target.routing_keys:
            forward_to = self.target.recipients[0]
            for routing_key in self.target.routing_keys:
                packed_message = crypto.pack_message(
                    forward_msg(to=forward_to, msg=packed_message).serialize(),
                    [routing_key],
                )
                forward_to = routing_key

        return json.dumps(packed_message).encode(&#34;ascii&#34;)

    @contextmanager
    def session(self, send: SessionSend):
        &#34;&#34;&#34;Open a new session for this connection.&#34;&#34;&#34;

        session = Session(self, send)
        self._sessions.add(session)
        yield session
        self._sessions.remove(session)

    def session_open(self) -&gt; bool:
        &#34;&#34;&#34;Check whether connection has sessions open.&#34;&#34;&#34;
        return bool(self._sessions)

    async def send_to_session(self, message: bytes, thread: str = None) -&gt; bool:
        &#34;&#34;&#34;Send a message to all sessions with a matching thread.&#34;&#34;&#34;
        if not self._sessions:
            raise RuntimeError(&#34;Cannot send message to session; no open sessions&#34;)

        sent = False
        for session in self._sessions:
            if not session.should_return_route():
                continue

            if session.thread == thread or session.thread_all():
                await session.send(message)
                sent = True
        return sent

    async def handle(self, packed_message: bytes, session: Session = None):
        &#34;&#34;&#34;Unpack and dispatch message to handler.&#34;&#34;&#34;
        msg = self.unpack(packed_message)
        if session:
            session.update_thread_from_msg(msg)

        for condition, next_message_future in self._next.items():
            if condition(msg) and not next_message_future.done():
                next_message_future.set_result(msg)
                return

        await self.dispatch(msg)

    async def send_async(
        self,
        msg: Union[dict, Message],
        *,
        return_route: str = None,
        plaintext: bool = False,
        anoncrypt: bool = False,
    ):
        &#34;&#34;&#34;
        Send a message to the agent connected through this Connection.
        &#34;&#34;&#34;
        if not isinstance(msg, Message):
            if isinstance(msg, dict):
                msg = Message.parse_obj(msg)
            else:
                raise TypeError(
                    f&#34;msg must be type Message or dict; received {type(msg)}&#34;
                )

        # TODO: Don&#39;t specify return route on messages sent to sessions?
        if return_route:
            msg = msg.with_transport(return_route=return_route)

        packed_message = self.pack(msg, anoncrypt=anoncrypt, plaintext=plaintext)

        if self.session_open():
            if await self.send_to_session(packed_message, msg.thread[&#34;thid&#34;]):
                return

        if not self.target or not self.target.endpoint:
            raise MessageDeliveryError(
                msg=&#34;Cannot send message; no endpoint and no return route.&#34;
            )

        try:
            response = await self._send(packed_message, self.target.endpoint)
        except Exception as err:
            raise MessageDeliveryError(msg=str(err)) from err

        if response:
            if return_route is None or return_route == &#34;none&#34;:
                raise RuntimeError(&#34;Response received when no response was expected&#34;)
            await self.handle(response)

    async def send_and_await_reply_async(
        self,
        msg: Union[dict, Message],
        *,
        type_: str = None,
        return_route: str = &#34;all&#34;,
        plaintext: bool = False,
        anoncrypt: bool = False,
        timeout: int = None,
    ) -&gt; Message:
        &#34;&#34;&#34;Send a message and wait for a reply to that message.&#34;&#34;&#34;
        hydrated = Message.parse_obj(msg) if not isinstance(msg, Message) else msg

        def _reply_match(returned: Message):
            return hydrated.id == returned.thread[&#34;thid&#34;]

        return await self.send_and_await_returned_async(
            msg,
            type_=type_,
            condition=_reply_match,
            return_route=return_route,
            plaintext=plaintext,
            anoncrypt=anoncrypt,
            timeout=timeout,
        )

    async def send_and_await_returned_async(
        self,
        msg: Union[dict, Message],
        *,
        type_: str = None,
        condition: Callable[[Message], bool] = None,
        return_route: str = &#34;all&#34;,
        plaintext: bool = False,
        anoncrypt: bool = False,
        timeout: int = None,
    ) -&gt; Message:
        &#34;&#34;&#34;Send a message and wait for a message to be returned.&#34;&#34;&#34;

        async def _time_boxed():
            with self.next(type_=type_, condition=condition) as next_message:
                await self.send_async(
                    msg,
                    return_route=return_route,
                    plaintext=plaintext,
                    anoncrypt=anoncrypt,
                )
                return await next_message

        return await asyncio.wait_for(_time_boxed(), timeout)

    async def await_message(
        self,
        *,
        type_: str = None,
        condition: Callable[[Message], bool] = None,
        timeout: int = None,
    ):
        &#34;&#34;&#34;
        Wait for a message.

        Note that it&#39;s possible for a message to arrive just before or during
        the setup of this function. If it&#39;s likely that a message will arrive
        as a result of an action taken prior to calling await_message, use the
        `next` context manager instead.
        &#34;&#34;&#34;
        with self.next(type_, condition=condition) as next_message:
            return await asyncio.wait_for(next_message, timeout)

    def send(self, *args, **kwargs):
        &#34;&#34;&#34;Blocking wrapper around send_async.&#34;&#34;&#34;
        loop = asyncio.get_event_loop()
        return loop.run_until_complete(self.send_async(*args, **kwargs))

    def send_and_await_reply(self, *args, **kwargs) -&gt; Message:
        &#34;&#34;&#34;Blocking wrapper around send_and_await_reply_async.&#34;&#34;&#34;
        loop = asyncio.get_event_loop()
        return loop.run_until_complete(self.send_and_await_reply_async(*args, **kwargs))

    def send_and_await_returned(self, *args, **kwargs) -&gt; Message:
        &#34;&#34;&#34;Blocking wrapper around send_and_await_reply_async.&#34;&#34;&#34;
        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.send_and_await_returned_async(*args, **kwargs)
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aries_staticagent.connection.Connection"><code class="flex name class">
<span>class <span class="ident">Connection</span></span>
<span>(</span><span>keys: <a title="aries_staticagent.connection.Keys" href="#aries_staticagent.connection.Keys">Keys</a>, target: <a title="aries_staticagent.connection.Target" href="#aries_staticagent.connection.Target">Target</a> = None, *, modules: Sequence[Union[<a title="aries_staticagent.module.Module" href="module.html#aries_staticagent.module.Module">Module</a>, type]] = None, send: Callable[[bytes, str], Awaitable[Optional[bytes]]] = None, dispatcher: <a title="aries_staticagent.dispatcher.Dispatcher" href="dispatcher.html#aries_staticagent.dispatcher.Dispatcher">Dispatcher</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Static Agent Connection to another agent.</p>
<p>The following will create a Static Connection with just the receiving end
in place. This makes it possible to receive a message over this connection
without yet knowing where messages will be sent.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; my_keys = crypto.create_keypair()
&gt;&gt;&gt; connection = Connection.receiver(my_keys)
</code></pre>
<p>To create a Static Agent Connection with both ends configured:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; their_pretend_verkey = crypto.create_keypair()[0]
&gt;&gt;&gt; connection = Connection.from_parts(
...     my_keys, their_vk=their_pretend_verkey
... )
</code></pre>
<p>Or, when there are multiple recipients:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pretend_recips = [ crypto.create_keypair()[0] for i in range(5) ]
&gt;&gt;&gt; connection = Connection.from_parts(
...     my_keys, recipients=pretend_recips
... )
</code></pre>
<p>To specify mediators responsible for forwarding messages to the recipient:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pretend_mediators = [ crypto.create_keypair()[0] for i in range(5) ]
&gt;&gt;&gt; connection = Connection.from_parts(
...     my_keys, their_vk=their_pretend_verkey,
...     routing_keys=pretend_mediators
... )
</code></pre>
<p>By default, <code><a title="aries_staticagent.connection.Connection" href="#aries_staticagent.connection.Connection">Connection</a></code> will POST messages to the endpoint given
over HTTP. You can, however, specify an alternative <code>Send</code> method for
<code><a title="aries_staticagent.connection.Connection" href="#aries_staticagent.connection.Connection">Connection</a></code> as in the example below:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; async def my_send(msg: bytes, endpoint: str) -&gt; Optional[bytes]:
...     print('pretending to send message to', endpoint)
...     response = None
...     return response
&gt;&gt;&gt; connection = Connection.from_parts(
...     my_keys, their_vk=their_pretend_verkey,
...     endpoint='example.com', send=my_send
... )
&gt;&gt;&gt; connection.send({'@type': 'doc_uri/protocol/0.1/test'})
pretending to send message to example.com
</code></pre>
<h2 id="arguments">Arguments</h2>
<p>keys (tuple of bytes or str): A tuple of our public and private key.</p>
<h2 id="namedarguments">Namedarguments</h2>
<p>their_vk (bytes or str): Specify "their" verification key for this
connection. Specifies only one recipient. Mutually exclusive with
recipients.</p>
<p>recipients ([bytes or str]): Specify one or more recipients for this
connection. Mutually exclusive with their_vk.</p>
<p>routing_keys ([bytes or str]): Specify one or more mediators for this
connection.</p>
<p>send (Send): Specify the send method for this connection. See notes
above for function signature.
Defaults to
<code><a title="aries_staticagent.utils.http_send" href="utils.html#aries_staticagent.utils.http_send">http_send()</a></code>.</p>
<p>dispatcher (aries_staticagent.dispatcher.Dispatcher): Specify a
dispatcher for this connection.
Defaults to
<code><a title="aries_staticagent.dispatcher.Dispatcher" href="dispatcher.html#aries_staticagent.dispatcher.Dispatcher">Dispatcher</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Connection(Keys.Mixin):
    &#34;&#34;&#34;Create a Static Agent Connection to another agent.

    The following will create a Static Connection with just the receiving end
    in place. This makes it possible to receive a message over this connection
    without yet knowing where messages will be sent.

    &gt;&gt;&gt; my_keys = crypto.create_keypair()
    &gt;&gt;&gt; connection = Connection.receiver(my_keys)

    To create a Static Agent Connection with both ends configured:
    &gt;&gt;&gt; their_pretend_verkey = crypto.create_keypair()[0]
    &gt;&gt;&gt; connection = Connection.from_parts(
    ...     my_keys, their_vk=their_pretend_verkey
    ... )

    Or, when there are multiple recipients:
    &gt;&gt;&gt; pretend_recips = [ crypto.create_keypair()[0] for i in range(5) ]
    &gt;&gt;&gt; connection = Connection.from_parts(
    ...     my_keys, recipients=pretend_recips
    ... )

    To specify mediators responsible for forwarding messages to the recipient:
    &gt;&gt;&gt; pretend_mediators = [ crypto.create_keypair()[0] for i in range(5) ]
    &gt;&gt;&gt; connection = Connection.from_parts(
    ...     my_keys, their_vk=their_pretend_verkey,
    ...     routing_keys=pretend_mediators
    ... )

    By default, `Connection` will POST messages to the endpoint given
    over HTTP. You can, however, specify an alternative `Send` method for
    `Connection` as in the example below:
    &gt;&gt;&gt; async def my_send(msg: bytes, endpoint: str) -&gt; Optional[bytes]:
    ...     print(&#39;pretending to send message to&#39;, endpoint)
    ...     response = None
    ...     return response
    &gt;&gt;&gt; connection = Connection.from_parts(
    ...     my_keys, their_vk=their_pretend_verkey,
    ...     endpoint=&#39;example.com&#39;, send=my_send
    ... )
    &gt;&gt;&gt; connection.send({&#39;@type&#39;: &#39;doc_uri/protocol/0.1/test&#39;})
    pretending to send message to example.com


    Arguments:

        keys (tuple of bytes or str): A tuple of our public and private key.

    NamedArguments:

        their_vk (bytes or str): Specify &#34;their&#34; verification key for this
            connection. Specifies only one recipient. Mutually exclusive with
            recipients.

        recipients ([bytes or str]): Specify one or more recipients for this
            connection. Mutually exclusive with their_vk.

        routing_keys ([bytes or str]): Specify one or more mediators for this
            connection.

        send (Send): Specify the send method for this connection. See notes
            above for function signature.  Defaults to
            `aries_staticagent.utils.http_send`.

        dispatcher (aries_staticagent.dispatcher.Dispatcher): Specify a
            dispatcher for this connection.  Defaults to
            `aries_staticagent.dispatcher.Dispatcher`.
    &#34;&#34;&#34;

    def __init__(
        self,
        keys: Keys,
        target: Target = None,
        *,
        modules: Sequence[Union[Module, type]] = None,
        send: Send = None,
        dispatcher: Dispatcher = None,
    ):

        Keys.Mixin.__init__(self, keys)
        self.target = target

        if modules:
            for mod in modules:
                if isinstance(mod, type):  # attempt to instantiate module
                    mod = mod()
                self.route_module(mod)

        self._send: Send = send or http_send
        self._dispatcher = dispatcher or Dispatcher()

        self._next: ConditionFutureMap = {}
        self._sessions: Set[Session] = set()

    @classmethod
    def from_parts(
        cls,
        keys: Union[Keys, Tuple[Keys.Key, Keys.Key]],
        *,
        endpoint: str = None,
        their_vk: Union[bytes, str] = None,
        recipients: Sequence[Union[bytes, str]] = None,
        routing_keys: Sequence[Union[bytes, str]] = None,
        **kwargs,
    ):
        &#34;&#34;&#34;Construct a static connection from its parts.

        Arguments:

            keys (tuple of bytes or str): A tuple of our public and private
            key.

        NamedArguments:

            their_vk (bytes or str): Specify &#34;their&#34; verification key for this
                connection. Specifies only one recipient. Mutually exclusive
                with recipients.

            recipients ([bytes or str]): Specify one or more recipients for
                this connection. Mutually exclusive with their_vk.

            routing_keys ([bytes or str]): Specify one or more mediators for
                this connection.

            send (Send): Specify the send method for this connection. See notes
                above for function signature.  Defaults to
                `aries_staticagent.utils.http_send`.

            dispatcher (aries_staticagent.dispatcher.Dispatcher): Specify a
                dispatcher for this connection.  Defaults to
                `aries_staticagent.dispatcher.Dispatcher`.
        &#34;&#34;&#34;
        if not isinstance(keys, Keys):
            keys = Keys(*keys)
        target = None
        if endpoint or their_vk or recipients or routing_keys:
            target = Target(
                endpoint=endpoint,
                their_vk=their_vk,
                recipients=recipients,
                routing_keys=routing_keys,
            )
        return cls(keys, target, **kwargs)

    @classmethod
    def receiver(cls, keys: Union[Keys, Tuple[Keys.Key, Keys.Key]], **kwargs):
        &#34;&#34;&#34;Create a static connection to be used only for receiving messages.

        Arguments:

            keys (Keys or Tuple of keys): Our public and private keys.
        &#34;&#34;&#34;
        if not isinstance(keys, Keys):
            keys = Keys(*keys)
        return cls(keys, **kwargs)

    @classmethod
    def random(cls, target: Target = None, **kwargs):
        &#34;&#34;&#34;Generate connection with random keys.&#34;&#34;&#34;
        return cls(Keys(*crypto.create_keypair()), target, **kwargs)

    @classmethod
    def from_seed(cls, seed: bytes, target: Target = None, **kwargs):
        &#34;&#34;&#34;Generate connection from seed.&#34;&#34;&#34;
        return cls(Keys(*crypto.create_keypair(seed=seed)), target, **kwargs)

    def route(self, msg_type: str) -&gt; Callable:
        &#34;&#34;&#34;Register route decorator.&#34;&#34;&#34;

        def register_route_dec(func):
            self._dispatcher.add_handler(Handler(MsgType(msg_type), func))
            return func

        return register_route_dec

    def route_module(self, module: Module):
        &#34;&#34;&#34;Register a module for routing.&#34;&#34;&#34;
        handlers = [Handler(msg_type, func) for msg_type, func in module.routes.items()]
        return self._dispatcher.add_handlers(handlers)

    def clear_routes(self):
        &#34;&#34;&#34;Clear registered routes.&#34;&#34;&#34;
        return self._dispatcher.clear_handlers()

    async def dispatch(self, message):
        &#34;&#34;&#34;
        Dispatch message to handler.
        &#34;&#34;&#34;
        await self._dispatcher.dispatch(message, self)

    @contextmanager
    def next(self, type_: str = None, condition: Callable[[Message], bool] = None):
        &#34;&#34;&#34;
        Context manager to claim the next message matching condtion, allowing
        temporary bypass of regular dispatch.

        This will consume only the next message matching condition. If you need
        to consume more than one or two, consider using a standard message
        handler or overriding the default dispatching mechanism.
        &#34;&#34;&#34;
        if condition and type_:
            raise ValueError(&#34;Expected type or condtion, not both.&#34;)
        if condition and not callable(condition):
            raise TypeError(&#34;condition must be Callable[[Message], bool]&#34;)

        if not condition and not type_:
            # Collect everything
            def _default(_msg):
                return True

            selected_condition = _default

        if type_:

            def _matches_type(msg):
                return msg.type == type_

            selected_condition = _matches_type

        if condition:
            selected_condition = condition

        next_message: asyncio.Future[Message] = asyncio.Future()
        self._next[selected_condition] = next_message

        yield next_message

        del self._next[selected_condition]

    def unpack(self, packed_message: Union[bytes, dict]) -&gt; Message:
        &#34;&#34;&#34;Unpack a message, filling out metadata in the MTC.&#34;&#34;&#34;
        try:
            (unpacked_msg, sender_vk, recip_vk) = crypto.unpack_message(
                packed_message, self.verkey, self.sigkey
            )
            msg = Message.deserialize(unpacked_msg)
            if sender_vk:
                msg.mtc.set_authcrypted(sender_vk, recip_vk)
            else:
                msg.mtc.set_anoncrypted(recip_vk)

        except (ValueError, KeyError):
            if not isinstance(packed_message, bytes):
                raise TypeError(&#34;Expected bytes, got {}&#34;.format(type(msg).__name__))
            msg = Message.deserialize(packed_message)
            msg.mtc.set_plaintext()

        return msg

    def pack(
        self, msg: Union[dict, Message], anoncrypt=False, plaintext=False
    ) -&gt; bytes:
        &#34;&#34;&#34;Pack a message for sending over the wire.&#34;&#34;&#34;
        if plaintext and anoncrypt:
            raise ValueError(&#34;plaintext and anoncrypt flags are mutually exclusive.&#34;)

        if not isinstance(msg, Message):
            if isinstance(msg, dict):
                msg = Message.parse_obj(msg)
            else:
                raise TypeError(
                    f&#34;msg must be type Message or dict; received {type(msg)}&#34;
                )

        if plaintext:
            return msg.serialize().encode(&#34;ascii&#34;)

        if not self.target or not self.target.recipients:
            raise RuntimeError(&#34;No recipients for whom to pack this message&#34;)

        if anoncrypt:
            packed_message = crypto.pack_message(
                msg.serialize(),
                self.target.recipients,
            )
        else:
            packed_message = crypto.pack_message(
                msg.serialize(),
                self.target.recipients,
                self.verkey,
                self.sigkey,
            )

        if self.target.routing_keys:
            forward_to = self.target.recipients[0]
            for routing_key in self.target.routing_keys:
                packed_message = crypto.pack_message(
                    forward_msg(to=forward_to, msg=packed_message).serialize(),
                    [routing_key],
                )
                forward_to = routing_key

        return json.dumps(packed_message).encode(&#34;ascii&#34;)

    @contextmanager
    def session(self, send: SessionSend):
        &#34;&#34;&#34;Open a new session for this connection.&#34;&#34;&#34;

        session = Session(self, send)
        self._sessions.add(session)
        yield session
        self._sessions.remove(session)

    def session_open(self) -&gt; bool:
        &#34;&#34;&#34;Check whether connection has sessions open.&#34;&#34;&#34;
        return bool(self._sessions)

    async def send_to_session(self, message: bytes, thread: str = None) -&gt; bool:
        &#34;&#34;&#34;Send a message to all sessions with a matching thread.&#34;&#34;&#34;
        if not self._sessions:
            raise RuntimeError(&#34;Cannot send message to session; no open sessions&#34;)

        sent = False
        for session in self._sessions:
            if not session.should_return_route():
                continue

            if session.thread == thread or session.thread_all():
                await session.send(message)
                sent = True
        return sent

    async def handle(self, packed_message: bytes, session: Session = None):
        &#34;&#34;&#34;Unpack and dispatch message to handler.&#34;&#34;&#34;
        msg = self.unpack(packed_message)
        if session:
            session.update_thread_from_msg(msg)

        for condition, next_message_future in self._next.items():
            if condition(msg) and not next_message_future.done():
                next_message_future.set_result(msg)
                return

        await self.dispatch(msg)

    async def send_async(
        self,
        msg: Union[dict, Message],
        *,
        return_route: str = None,
        plaintext: bool = False,
        anoncrypt: bool = False,
    ):
        &#34;&#34;&#34;
        Send a message to the agent connected through this Connection.
        &#34;&#34;&#34;
        if not isinstance(msg, Message):
            if isinstance(msg, dict):
                msg = Message.parse_obj(msg)
            else:
                raise TypeError(
                    f&#34;msg must be type Message or dict; received {type(msg)}&#34;
                )

        # TODO: Don&#39;t specify return route on messages sent to sessions?
        if return_route:
            msg = msg.with_transport(return_route=return_route)

        packed_message = self.pack(msg, anoncrypt=anoncrypt, plaintext=plaintext)

        if self.session_open():
            if await self.send_to_session(packed_message, msg.thread[&#34;thid&#34;]):
                return

        if not self.target or not self.target.endpoint:
            raise MessageDeliveryError(
                msg=&#34;Cannot send message; no endpoint and no return route.&#34;
            )

        try:
            response = await self._send(packed_message, self.target.endpoint)
        except Exception as err:
            raise MessageDeliveryError(msg=str(err)) from err

        if response:
            if return_route is None or return_route == &#34;none&#34;:
                raise RuntimeError(&#34;Response received when no response was expected&#34;)
            await self.handle(response)

    async def send_and_await_reply_async(
        self,
        msg: Union[dict, Message],
        *,
        type_: str = None,
        return_route: str = &#34;all&#34;,
        plaintext: bool = False,
        anoncrypt: bool = False,
        timeout: int = None,
    ) -&gt; Message:
        &#34;&#34;&#34;Send a message and wait for a reply to that message.&#34;&#34;&#34;
        hydrated = Message.parse_obj(msg) if not isinstance(msg, Message) else msg

        def _reply_match(returned: Message):
            return hydrated.id == returned.thread[&#34;thid&#34;]

        return await self.send_and_await_returned_async(
            msg,
            type_=type_,
            condition=_reply_match,
            return_route=return_route,
            plaintext=plaintext,
            anoncrypt=anoncrypt,
            timeout=timeout,
        )

    async def send_and_await_returned_async(
        self,
        msg: Union[dict, Message],
        *,
        type_: str = None,
        condition: Callable[[Message], bool] = None,
        return_route: str = &#34;all&#34;,
        plaintext: bool = False,
        anoncrypt: bool = False,
        timeout: int = None,
    ) -&gt; Message:
        &#34;&#34;&#34;Send a message and wait for a message to be returned.&#34;&#34;&#34;

        async def _time_boxed():
            with self.next(type_=type_, condition=condition) as next_message:
                await self.send_async(
                    msg,
                    return_route=return_route,
                    plaintext=plaintext,
                    anoncrypt=anoncrypt,
                )
                return await next_message

        return await asyncio.wait_for(_time_boxed(), timeout)

    async def await_message(
        self,
        *,
        type_: str = None,
        condition: Callable[[Message], bool] = None,
        timeout: int = None,
    ):
        &#34;&#34;&#34;
        Wait for a message.

        Note that it&#39;s possible for a message to arrive just before or during
        the setup of this function. If it&#39;s likely that a message will arrive
        as a result of an action taken prior to calling await_message, use the
        `next` context manager instead.
        &#34;&#34;&#34;
        with self.next(type_, condition=condition) as next_message:
            return await asyncio.wait_for(next_message, timeout)

    def send(self, *args, **kwargs):
        &#34;&#34;&#34;Blocking wrapper around send_async.&#34;&#34;&#34;
        loop = asyncio.get_event_loop()
        return loop.run_until_complete(self.send_async(*args, **kwargs))

    def send_and_await_reply(self, *args, **kwargs) -&gt; Message:
        &#34;&#34;&#34;Blocking wrapper around send_and_await_reply_async.&#34;&#34;&#34;
        loop = asyncio.get_event_loop()
        return loop.run_until_complete(self.send_and_await_reply_async(*args, **kwargs))

    def send_and_await_returned(self, *args, **kwargs) -&gt; Message:
        &#34;&#34;&#34;Blocking wrapper around send_and_await_reply_async.&#34;&#34;&#34;
        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.send_and_await_returned_async(*args, **kwargs)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aries_staticagent.connection.Keys.Mixin" href="#aries_staticagent.connection.Keys.Mixin">Keys.Mixin</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="aries_staticagent.connection.Connection.from_parts"><code class="name flex">
<span>def <span class="ident">from_parts</span></span>(<span>keys: Union[<a title="aries_staticagent.connection.Keys" href="#aries_staticagent.connection.Keys">Keys</a>, Tuple[Union[bytes, str], Union[bytes, str]]], *, endpoint: str = None, their_vk: Union[bytes, str] = None, recipients: Sequence[Union[bytes, str]] = None, routing_keys: Sequence[Union[bytes, str]] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a static connection from its parts.</p>
<h2 id="arguments">Arguments</h2>
<p>keys (tuple of bytes or str): A tuple of our public and private
key.</p>
<h2 id="namedarguments">Namedarguments</h2>
<p>their_vk (bytes or str): Specify "their" verification key for this
connection. Specifies only one recipient. Mutually exclusive
with recipients.</p>
<p>recipients ([bytes or str]): Specify one or more recipients for
this connection. Mutually exclusive with their_vk.</p>
<p>routing_keys ([bytes or str]): Specify one or more mediators for
this connection.</p>
<p>send (Send): Specify the send method for this connection. See notes
above for function signature.
Defaults to
<code><a title="aries_staticagent.utils.http_send" href="utils.html#aries_staticagent.utils.http_send">http_send()</a></code>.</p>
<p>dispatcher (aries_staticagent.dispatcher.Dispatcher): Specify a
dispatcher for this connection.
Defaults to
<code><a title="aries_staticagent.dispatcher.Dispatcher" href="dispatcher.html#aries_staticagent.dispatcher.Dispatcher">Dispatcher</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_parts(
    cls,
    keys: Union[Keys, Tuple[Keys.Key, Keys.Key]],
    *,
    endpoint: str = None,
    their_vk: Union[bytes, str] = None,
    recipients: Sequence[Union[bytes, str]] = None,
    routing_keys: Sequence[Union[bytes, str]] = None,
    **kwargs,
):
    &#34;&#34;&#34;Construct a static connection from its parts.

    Arguments:

        keys (tuple of bytes or str): A tuple of our public and private
        key.

    NamedArguments:

        their_vk (bytes or str): Specify &#34;their&#34; verification key for this
            connection. Specifies only one recipient. Mutually exclusive
            with recipients.

        recipients ([bytes or str]): Specify one or more recipients for
            this connection. Mutually exclusive with their_vk.

        routing_keys ([bytes or str]): Specify one or more mediators for
            this connection.

        send (Send): Specify the send method for this connection. See notes
            above for function signature.  Defaults to
            `aries_staticagent.utils.http_send`.

        dispatcher (aries_staticagent.dispatcher.Dispatcher): Specify a
            dispatcher for this connection.  Defaults to
            `aries_staticagent.dispatcher.Dispatcher`.
    &#34;&#34;&#34;
    if not isinstance(keys, Keys):
        keys = Keys(*keys)
    target = None
    if endpoint or their_vk or recipients or routing_keys:
        target = Target(
            endpoint=endpoint,
            their_vk=their_vk,
            recipients=recipients,
            routing_keys=routing_keys,
        )
    return cls(keys, target, **kwargs)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.from_seed"><code class="name flex">
<span>def <span class="ident">from_seed</span></span>(<span>seed: bytes, target: <a title="aries_staticagent.connection.Target" href="#aries_staticagent.connection.Target">Target</a> = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate connection from seed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_seed(cls, seed: bytes, target: Target = None, **kwargs):
    &#34;&#34;&#34;Generate connection from seed.&#34;&#34;&#34;
    return cls(Keys(*crypto.create_keypair(seed=seed)), target, **kwargs)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.random"><code class="name flex">
<span>def <span class="ident">random</span></span>(<span>target: <a title="aries_staticagent.connection.Target" href="#aries_staticagent.connection.Target">Target</a> = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate connection with random keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def random(cls, target: Target = None, **kwargs):
    &#34;&#34;&#34;Generate connection with random keys.&#34;&#34;&#34;
    return cls(Keys(*crypto.create_keypair()), target, **kwargs)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.receiver"><code class="name flex">
<span>def <span class="ident">receiver</span></span>(<span>keys: Union[<a title="aries_staticagent.connection.Keys" href="#aries_staticagent.connection.Keys">Keys</a>, Tuple[Union[bytes, str], Union[bytes, str]]], **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a static connection to be used only for receiving messages.</p>
<h2 id="arguments">Arguments</h2>
<p>keys (Keys or Tuple of keys): Our public and private keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def receiver(cls, keys: Union[Keys, Tuple[Keys.Key, Keys.Key]], **kwargs):
    &#34;&#34;&#34;Create a static connection to be used only for receiving messages.

    Arguments:

        keys (Keys or Tuple of keys): Our public and private keys.
    &#34;&#34;&#34;
    if not isinstance(keys, Keys):
        keys = Keys(*keys)
    return cls(keys, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="aries_staticagent.connection.Connection.await_message"><code class="name flex">
<span>async def <span class="ident">await_message</span></span>(<span>self, *, type_: str = None, condition: Callable[[<a title="aries_staticagent.message.Message" href="message.html#aries_staticagent.message.Message">Message</a>], bool] = None, timeout: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for a message.</p>
<p>Note that it's possible for a message to arrive just before or during
the setup of this function. If it's likely that a message will arrive
as a result of an action taken prior to calling await_message, use the
<code>next</code> context manager instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def await_message(
    self,
    *,
    type_: str = None,
    condition: Callable[[Message], bool] = None,
    timeout: int = None,
):
    &#34;&#34;&#34;
    Wait for a message.

    Note that it&#39;s possible for a message to arrive just before or during
    the setup of this function. If it&#39;s likely that a message will arrive
    as a result of an action taken prior to calling await_message, use the
    `next` context manager instead.
    &#34;&#34;&#34;
    with self.next(type_, condition=condition) as next_message:
        return await asyncio.wait_for(next_message, timeout)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.clear_routes"><code class="name flex">
<span>def <span class="ident">clear_routes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear registered routes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_routes(self):
    &#34;&#34;&#34;Clear registered routes.&#34;&#34;&#34;
    return self._dispatcher.clear_handlers()</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.dispatch"><code class="name flex">
<span>async def <span class="ident">dispatch</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Dispatch message to handler.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def dispatch(self, message):
    &#34;&#34;&#34;
    Dispatch message to handler.
    &#34;&#34;&#34;
    await self._dispatcher.dispatch(message, self)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.handle"><code class="name flex">
<span>async def <span class="ident">handle</span></span>(<span>self, packed_message: bytes, session: <a title="aries_staticagent.connection.Session" href="#aries_staticagent.connection.Session">Session</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Unpack and dispatch message to handler.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle(self, packed_message: bytes, session: Session = None):
    &#34;&#34;&#34;Unpack and dispatch message to handler.&#34;&#34;&#34;
    msg = self.unpack(packed_message)
    if session:
        session.update_thread_from_msg(msg)

    for condition, next_message_future in self._next.items():
        if condition(msg) and not next_message_future.done():
            next_message_future.set_result(msg)
            return

    await self.dispatch(msg)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.next"><code class="name flex">
<span>def <span class="ident">next</span></span>(<span>self, type_: str = None, condition: Callable[[<a title="aries_staticagent.message.Message" href="message.html#aries_staticagent.message.Message">Message</a>], bool] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Context manager to claim the next message matching condtion, allowing
temporary bypass of regular dispatch.</p>
<p>This will consume only the next message matching condition. If you need
to consume more than one or two, consider using a standard message
handler or overriding the default dispatching mechanism.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def next(self, type_: str = None, condition: Callable[[Message], bool] = None):
    &#34;&#34;&#34;
    Context manager to claim the next message matching condtion, allowing
    temporary bypass of regular dispatch.

    This will consume only the next message matching condition. If you need
    to consume more than one or two, consider using a standard message
    handler or overriding the default dispatching mechanism.
    &#34;&#34;&#34;
    if condition and type_:
        raise ValueError(&#34;Expected type or condtion, not both.&#34;)
    if condition and not callable(condition):
        raise TypeError(&#34;condition must be Callable[[Message], bool]&#34;)

    if not condition and not type_:
        # Collect everything
        def _default(_msg):
            return True

        selected_condition = _default

    if type_:

        def _matches_type(msg):
            return msg.type == type_

        selected_condition = _matches_type

    if condition:
        selected_condition = condition

    next_message: asyncio.Future[Message] = asyncio.Future()
    self._next[selected_condition] = next_message

    yield next_message

    del self._next[selected_condition]</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.pack"><code class="name flex">
<span>def <span class="ident">pack</span></span>(<span>self, msg: Union[dict, <a title="aries_staticagent.message.Message" href="message.html#aries_staticagent.message.Message">Message</a>], anoncrypt=False, plaintext=False) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Pack a message for sending over the wire.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pack(
    self, msg: Union[dict, Message], anoncrypt=False, plaintext=False
) -&gt; bytes:
    &#34;&#34;&#34;Pack a message for sending over the wire.&#34;&#34;&#34;
    if plaintext and anoncrypt:
        raise ValueError(&#34;plaintext and anoncrypt flags are mutually exclusive.&#34;)

    if not isinstance(msg, Message):
        if isinstance(msg, dict):
            msg = Message.parse_obj(msg)
        else:
            raise TypeError(
                f&#34;msg must be type Message or dict; received {type(msg)}&#34;
            )

    if plaintext:
        return msg.serialize().encode(&#34;ascii&#34;)

    if not self.target or not self.target.recipients:
        raise RuntimeError(&#34;No recipients for whom to pack this message&#34;)

    if anoncrypt:
        packed_message = crypto.pack_message(
            msg.serialize(),
            self.target.recipients,
        )
    else:
        packed_message = crypto.pack_message(
            msg.serialize(),
            self.target.recipients,
            self.verkey,
            self.sigkey,
        )

    if self.target.routing_keys:
        forward_to = self.target.recipients[0]
        for routing_key in self.target.routing_keys:
            packed_message = crypto.pack_message(
                forward_msg(to=forward_to, msg=packed_message).serialize(),
                [routing_key],
            )
            forward_to = routing_key

    return json.dumps(packed_message).encode(&#34;ascii&#34;)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.route"><code class="name flex">
<span>def <span class="ident">route</span></span>(<span>self, msg_type: str) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Register route decorator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def route(self, msg_type: str) -&gt; Callable:
    &#34;&#34;&#34;Register route decorator.&#34;&#34;&#34;

    def register_route_dec(func):
        self._dispatcher.add_handler(Handler(MsgType(msg_type), func))
        return func

    return register_route_dec</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.route_module"><code class="name flex">
<span>def <span class="ident">route_module</span></span>(<span>self, module: <a title="aries_staticagent.module.Module" href="module.html#aries_staticagent.module.Module">Module</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Register a module for routing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def route_module(self, module: Module):
    &#34;&#34;&#34;Register a module for routing.&#34;&#34;&#34;
    handlers = [Handler(msg_type, func) for msg_type, func in module.routes.items()]
    return self._dispatcher.add_handlers(handlers)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Blocking wrapper around send_async.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, *args, **kwargs):
    &#34;&#34;&#34;Blocking wrapper around send_async.&#34;&#34;&#34;
    loop = asyncio.get_event_loop()
    return loop.run_until_complete(self.send_async(*args, **kwargs))</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.send_and_await_reply"><code class="name flex">
<span>def <span class="ident">send_and_await_reply</span></span>(<span>self, *args, **kwargs) ‑> <a title="aries_staticagent.message.Message" href="message.html#aries_staticagent.message.Message">Message</a></span>
</code></dt>
<dd>
<div class="desc"><p>Blocking wrapper around send_and_await_reply_async.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_and_await_reply(self, *args, **kwargs) -&gt; Message:
    &#34;&#34;&#34;Blocking wrapper around send_and_await_reply_async.&#34;&#34;&#34;
    loop = asyncio.get_event_loop()
    return loop.run_until_complete(self.send_and_await_reply_async(*args, **kwargs))</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.send_and_await_reply_async"><code class="name flex">
<span>async def <span class="ident">send_and_await_reply_async</span></span>(<span>self, msg: Union[dict, <a title="aries_staticagent.message.Message" href="message.html#aries_staticagent.message.Message">Message</a>], *, type_: str = None, return_route: str = 'all', plaintext: bool = False, anoncrypt: bool = False, timeout: int = None) ‑> <a title="aries_staticagent.message.Message" href="message.html#aries_staticagent.message.Message">Message</a></span>
</code></dt>
<dd>
<div class="desc"><p>Send a message and wait for a reply to that message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_and_await_reply_async(
    self,
    msg: Union[dict, Message],
    *,
    type_: str = None,
    return_route: str = &#34;all&#34;,
    plaintext: bool = False,
    anoncrypt: bool = False,
    timeout: int = None,
) -&gt; Message:
    &#34;&#34;&#34;Send a message and wait for a reply to that message.&#34;&#34;&#34;
    hydrated = Message.parse_obj(msg) if not isinstance(msg, Message) else msg

    def _reply_match(returned: Message):
        return hydrated.id == returned.thread[&#34;thid&#34;]

    return await self.send_and_await_returned_async(
        msg,
        type_=type_,
        condition=_reply_match,
        return_route=return_route,
        plaintext=plaintext,
        anoncrypt=anoncrypt,
        timeout=timeout,
    )</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.send_and_await_returned"><code class="name flex">
<span>def <span class="ident">send_and_await_returned</span></span>(<span>self, *args, **kwargs) ‑> <a title="aries_staticagent.message.Message" href="message.html#aries_staticagent.message.Message">Message</a></span>
</code></dt>
<dd>
<div class="desc"><p>Blocking wrapper around send_and_await_reply_async.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_and_await_returned(self, *args, **kwargs) -&gt; Message:
    &#34;&#34;&#34;Blocking wrapper around send_and_await_reply_async.&#34;&#34;&#34;
    loop = asyncio.get_event_loop()
    return loop.run_until_complete(
        self.send_and_await_returned_async(*args, **kwargs)
    )</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.send_and_await_returned_async"><code class="name flex">
<span>async def <span class="ident">send_and_await_returned_async</span></span>(<span>self, msg: Union[dict, <a title="aries_staticagent.message.Message" href="message.html#aries_staticagent.message.Message">Message</a>], *, type_: str = None, condition: Callable[[<a title="aries_staticagent.message.Message" href="message.html#aries_staticagent.message.Message">Message</a>], bool] = None, return_route: str = 'all', plaintext: bool = False, anoncrypt: bool = False, timeout: int = None) ‑> <a title="aries_staticagent.message.Message" href="message.html#aries_staticagent.message.Message">Message</a></span>
</code></dt>
<dd>
<div class="desc"><p>Send a message and wait for a message to be returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_and_await_returned_async(
    self,
    msg: Union[dict, Message],
    *,
    type_: str = None,
    condition: Callable[[Message], bool] = None,
    return_route: str = &#34;all&#34;,
    plaintext: bool = False,
    anoncrypt: bool = False,
    timeout: int = None,
) -&gt; Message:
    &#34;&#34;&#34;Send a message and wait for a message to be returned.&#34;&#34;&#34;

    async def _time_boxed():
        with self.next(type_=type_, condition=condition) as next_message:
            await self.send_async(
                msg,
                return_route=return_route,
                plaintext=plaintext,
                anoncrypt=anoncrypt,
            )
            return await next_message

    return await asyncio.wait_for(_time_boxed(), timeout)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.send_async"><code class="name flex">
<span>async def <span class="ident">send_async</span></span>(<span>self, msg: Union[dict, <a title="aries_staticagent.message.Message" href="message.html#aries_staticagent.message.Message">Message</a>], *, return_route: str = None, plaintext: bool = False, anoncrypt: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a message to the agent connected through this Connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_async(
    self,
    msg: Union[dict, Message],
    *,
    return_route: str = None,
    plaintext: bool = False,
    anoncrypt: bool = False,
):
    &#34;&#34;&#34;
    Send a message to the agent connected through this Connection.
    &#34;&#34;&#34;
    if not isinstance(msg, Message):
        if isinstance(msg, dict):
            msg = Message.parse_obj(msg)
        else:
            raise TypeError(
                f&#34;msg must be type Message or dict; received {type(msg)}&#34;
            )

    # TODO: Don&#39;t specify return route on messages sent to sessions?
    if return_route:
        msg = msg.with_transport(return_route=return_route)

    packed_message = self.pack(msg, anoncrypt=anoncrypt, plaintext=plaintext)

    if self.session_open():
        if await self.send_to_session(packed_message, msg.thread[&#34;thid&#34;]):
            return

    if not self.target or not self.target.endpoint:
        raise MessageDeliveryError(
            msg=&#34;Cannot send message; no endpoint and no return route.&#34;
        )

    try:
        response = await self._send(packed_message, self.target.endpoint)
    except Exception as err:
        raise MessageDeliveryError(msg=str(err)) from err

    if response:
        if return_route is None or return_route == &#34;none&#34;:
            raise RuntimeError(&#34;Response received when no response was expected&#34;)
        await self.handle(response)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.send_to_session"><code class="name flex">
<span>async def <span class="ident">send_to_session</span></span>(<span>self, message: bytes, thread: str = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Send a message to all sessions with a matching thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_to_session(self, message: bytes, thread: str = None) -&gt; bool:
    &#34;&#34;&#34;Send a message to all sessions with a matching thread.&#34;&#34;&#34;
    if not self._sessions:
        raise RuntimeError(&#34;Cannot send message to session; no open sessions&#34;)

    sent = False
    for session in self._sessions:
        if not session.should_return_route():
            continue

        if session.thread == thread or session.thread_all():
            await session.send(message)
            sent = True
    return sent</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.session"><code class="name flex">
<span>def <span class="ident">session</span></span>(<span>self, send: Callable[[bytes], Awaitable[None]])</span>
</code></dt>
<dd>
<div class="desc"><p>Open a new session for this connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def session(self, send: SessionSend):
    &#34;&#34;&#34;Open a new session for this connection.&#34;&#34;&#34;

    session = Session(self, send)
    self._sessions.add(session)
    yield session
    self._sessions.remove(session)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.session_open"><code class="name flex">
<span>def <span class="ident">session_open</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether connection has sessions open.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def session_open(self) -&gt; bool:
    &#34;&#34;&#34;Check whether connection has sessions open.&#34;&#34;&#34;
    return bool(self._sessions)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Connection.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self, packed_message: Union[bytes, dict]) ‑> <a title="aries_staticagent.message.Message" href="message.html#aries_staticagent.message.Message">Message</a></span>
</code></dt>
<dd>
<div class="desc"><p>Unpack a message, filling out metadata in the MTC.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unpack(self, packed_message: Union[bytes, dict]) -&gt; Message:
    &#34;&#34;&#34;Unpack a message, filling out metadata in the MTC.&#34;&#34;&#34;
    try:
        (unpacked_msg, sender_vk, recip_vk) = crypto.unpack_message(
            packed_message, self.verkey, self.sigkey
        )
        msg = Message.deserialize(unpacked_msg)
        if sender_vk:
            msg.mtc.set_authcrypted(sender_vk, recip_vk)
        else:
            msg.mtc.set_anoncrypted(recip_vk)

    except (ValueError, KeyError):
        if not isinstance(packed_message, bytes):
            raise TypeError(&#34;Expected bytes, got {}&#34;.format(type(msg).__name__))
        msg = Message.deserialize(packed_message)
        msg.mtc.set_plaintext()

    return msg</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aries_staticagent.connection.Keys"><code class="flex name class">
<span>class <span class="ident">Keys</span></span>
<span>(</span><span>verkey: Union[bytes, str], sigkey: Union[bytes, str])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Keys:
    Key = Union[bytes, str]

    &#34;&#34;&#34;Container for keys with convenience methods.&#34;&#34;&#34;

    class Mixin:
        &#34;&#34;&#34;Mixin for shortcuts to keys.&#34;&#34;&#34;

        def __init__(self, keys: &#34;Keys&#34;):
            self.keys = keys

        @property
        def verkey(self):
            &#34;&#34;&#34;Get verkey.&#34;&#34;&#34;
            return self.keys.verkey

        @property
        def verkey_b58(self):
            &#34;&#34;&#34;Get Base58 encoded verkey.&#34;&#34;&#34;
            return self.keys.verkey_b58

        @property
        def sigkey(self):
            &#34;&#34;&#34;Get sigkey.&#34;&#34;&#34;
            return self.keys.sigkey

        @property
        def did(self):
            &#34;&#34;&#34;Get verkey based DID for this connection.&#34;&#34;&#34;
            return self.keys.did

    def __init__(self, verkey: Key, sigkey: Key):
        self._verkey = ensure_key_bytes(verkey)
        self._sigkey = ensure_key_bytes(sigkey)

    @property
    def verkey(self):
        &#34;&#34;&#34;Get verkey.&#34;&#34;&#34;
        return self._verkey

    @property
    def verkey_b58(self):
        &#34;&#34;&#34;Get Base58 encoded verkey.&#34;&#34;&#34;
        return crypto.bytes_to_b58(self.verkey)

    @property
    def sigkey(self):
        &#34;&#34;&#34;Get sigkey.&#34;&#34;&#34;
        return self._sigkey

    @property
    def did(self):
        &#34;&#34;&#34;Get verkey based DID for this connection.&#34;&#34;&#34;
        return crypto.bytes_to_b58(self._verkey[:16])

    def __str__(self):
        return &#34;Keys({}, {}...)&#34;.format(
            self.verkey_b58, crypto.bytes_to_b58(self.sigkey)[:10]
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="aries_staticagent.connection.Keys.Key"><code class="name">var <span class="ident">Key</span></code></dt>
<dd>
<div class="desc"><p>Container for keys with convenience methods.</p></div>
</dd>
<dt id="aries_staticagent.connection.Keys.Mixin"><code class="name">var <span class="ident">Mixin</span></code></dt>
<dd>
<div class="desc"><p>Mixin for shortcuts to keys.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="aries_staticagent.connection.Keys.did"><code class="name">var <span class="ident">did</span></code></dt>
<dd>
<div class="desc"><p>Get verkey based DID for this connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def did(self):
    &#34;&#34;&#34;Get verkey based DID for this connection.&#34;&#34;&#34;
    return crypto.bytes_to_b58(self._verkey[:16])</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Keys.sigkey"><code class="name">var <span class="ident">sigkey</span></code></dt>
<dd>
<div class="desc"><p>Get sigkey.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sigkey(self):
    &#34;&#34;&#34;Get sigkey.&#34;&#34;&#34;
    return self._sigkey</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Keys.verkey"><code class="name">var <span class="ident">verkey</span></code></dt>
<dd>
<div class="desc"><p>Get verkey.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def verkey(self):
    &#34;&#34;&#34;Get verkey.&#34;&#34;&#34;
    return self._verkey</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Keys.verkey_b58"><code class="name">var <span class="ident">verkey_b58</span></code></dt>
<dd>
<div class="desc"><p>Get Base58 encoded verkey.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def verkey_b58(self):
    &#34;&#34;&#34;Get Base58 encoded verkey.&#34;&#34;&#34;
    return crypto.bytes_to_b58(self.verkey)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aries_staticagent.connection.MessageDeliveryError"><code class="flex name class">
<span>class <span class="ident">MessageDeliveryError</span></span>
<span>(</span><span>*, status: int = None, msg: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>When a message cannot be delivered.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MessageDeliveryError(Exception):
    &#34;&#34;&#34;When a message cannot be delivered.&#34;&#34;&#34;

    def __init__(self, *, status: int = None, msg: str = None):
        super().__init__(msg)
        self.status = status</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="aries_staticagent.connection.Session"><code class="flex name class">
<span>class <span class="ident">Session</span></span>
<span>(</span><span>conn: <a title="aries_staticagent.connection.Connection" href="#aries_staticagent.connection.Connection">Connection</a>, send: Callable[[bytes], Awaitable[None]], thread: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>An active transport-layer connection/socket providing a send method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Session:
    &#34;&#34;&#34;An active transport-layer connection/socket providing a send method.&#34;&#34;&#34;

    THREAD_ALL = &#34;all&#34;

    def __init__(self, conn: &#34;Connection&#34;, send: SessionSend, thread: str = None):
        if send is None:
            raise TypeError(&#34;Must supply send method to Session&#34;)

        if not callable(send) and not asyncio.iscoroutine(send):
            raise TypeError(
                &#34;Invalid send method; expected coroutine or function, got {}&#34;.format(
                    type(send).__name__
                )
            )

        self._id = str(uuid.uuid4())
        self._conn = conn
        self._send = send
        self._thread = thread
        self._status = None

    @property
    def session_id(self):
        &#34;&#34;&#34;Unique Identifier for this session.&#34;&#34;&#34;
        return self._id

    @property
    def thread(self):
        &#34;&#34;&#34;Get this session&#39;s assigned thread.&#34;&#34;&#34;
        return self._thread

    def update_thread_from_msg(self, msg: Message):
        &#34;&#34;&#34;Update a thread with info from the ~transport decorator.&#34;&#34;&#34;
        if &#34;~transport&#34; not in msg and self._thread is None:
            return

        transport = msg[&#34;~transport&#34;]
        if transport[&#34;return_route&#34;] == &#34;all&#34;:
            self._thread = self.THREAD_ALL
            return

        if transport[&#34;return_route&#34;] == &#34;thread&#34;:
            self._thread = transport[&#34;return_route_thread&#34;]
            return

        if transport[&#34;return_route&#34;] == &#34;none&#34;:
            self._thread = None
            return

    def should_return_route(self) -&gt; bool:
        &#34;&#34;&#34;Session set to return route?&#34;&#34;&#34;
        return bool(self._thread)

    def thread_all(self) -&gt; bool:
        &#34;&#34;&#34;Session is set to return all messages.&#34;&#34;&#34;
        return self.thread == self.THREAD_ALL

    async def send(self, message: bytes):
        &#34;&#34;&#34;Send a packed message to this session.&#34;&#34;&#34;
        if not self.should_return_route():
            raise RuntimeError(&#34;Session is not set to return route&#34;)

        ret = self._send(message)
        if asyncio.iscoroutine(ret):
            return await ret

        return ret

    async def handle(self, message: bytes):
        &#34;&#34;&#34;
        Handle a message received over this session.

        Delegates to connection&#39;s handle.
        &#34;&#34;&#34;
        return await self._conn.handle(message, self)

    def __hash__(self):
        return hash(self.session_id)

    def __eq__(self, other):
        if not isinstance(other, Session):
            return False
        return self.session_id == other.session_id</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="aries_staticagent.connection.Session.THREAD_ALL"><code class="name">var <span class="ident">THREAD_ALL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="aries_staticagent.connection.Session.session_id"><code class="name">var <span class="ident">session_id</span></code></dt>
<dd>
<div class="desc"><p>Unique Identifier for this session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def session_id(self):
    &#34;&#34;&#34;Unique Identifier for this session.&#34;&#34;&#34;
    return self._id</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Session.thread"><code class="name">var <span class="ident">thread</span></code></dt>
<dd>
<div class="desc"><p>Get this session's assigned thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def thread(self):
    &#34;&#34;&#34;Get this session&#39;s assigned thread.&#34;&#34;&#34;
    return self._thread</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="aries_staticagent.connection.Session.handle"><code class="name flex">
<span>async def <span class="ident">handle</span></span>(<span>self, message: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle a message received over this session.</p>
<p>Delegates to connection's handle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle(self, message: bytes):
    &#34;&#34;&#34;
    Handle a message received over this session.

    Delegates to connection&#39;s handle.
    &#34;&#34;&#34;
    return await self._conn.handle(message, self)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Session.send"><code class="name flex">
<span>async def <span class="ident">send</span></span>(<span>self, message: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a packed message to this session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send(self, message: bytes):
    &#34;&#34;&#34;Send a packed message to this session.&#34;&#34;&#34;
    if not self.should_return_route():
        raise RuntimeError(&#34;Session is not set to return route&#34;)

    ret = self._send(message)
    if asyncio.iscoroutine(ret):
        return await ret

    return ret</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Session.should_return_route"><code class="name flex">
<span>def <span class="ident">should_return_route</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Session set to return route?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def should_return_route(self) -&gt; bool:
    &#34;&#34;&#34;Session set to return route?&#34;&#34;&#34;
    return bool(self._thread)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Session.thread_all"><code class="name flex">
<span>def <span class="ident">thread_all</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Session is set to return all messages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thread_all(self) -&gt; bool:
    &#34;&#34;&#34;Session is set to return all messages.&#34;&#34;&#34;
    return self.thread == self.THREAD_ALL</code></pre>
</details>
</dd>
<dt id="aries_staticagent.connection.Session.update_thread_from_msg"><code class="name flex">
<span>def <span class="ident">update_thread_from_msg</span></span>(<span>self, msg: <a title="aries_staticagent.message.Message" href="message.html#aries_staticagent.message.Message">Message</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Update a thread with info from the ~transport decorator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_thread_from_msg(self, msg: Message):
    &#34;&#34;&#34;Update a thread with info from the ~transport decorator.&#34;&#34;&#34;
    if &#34;~transport&#34; not in msg and self._thread is None:
        return

    transport = msg[&#34;~transport&#34;]
    if transport[&#34;return_route&#34;] == &#34;all&#34;:
        self._thread = self.THREAD_ALL
        return

    if transport[&#34;return_route&#34;] == &#34;thread&#34;:
        self._thread = transport[&#34;return_route_thread&#34;]
        return

    if transport[&#34;return_route&#34;] == &#34;none&#34;:
        self._thread = None
        return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aries_staticagent.connection.Target"><code class="flex name class">
<span>class <span class="ident">Target</span></span>
<span>(</span><span>*, endpoint: str = None, their_vk: Union[bytes, str] = None, recipients: Sequence[Union[bytes, str]] = None, routing_keys: Sequence[Union[bytes, str]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Container for information about our message destination.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Target:
    &#34;&#34;&#34;Container for information about our message destination.&#34;&#34;&#34;

    def __init__(
        self,
        *,
        endpoint: str = None,
        their_vk: Union[bytes, str] = None,
        recipients: Sequence[Union[bytes, str]] = None,
        routing_keys: Sequence[Union[bytes, str]] = None,
    ):
        if their_vk and recipients:
            raise ValueError(&#34;their_vk and recipients are mutually exclusive.&#34;)

        self.endpoint: Optional[str] = endpoint
        self.recipients: Optional[List[bytes]] = None
        self.routing_keys: Optional[List[bytes]] = None

        if their_vk:
            self.recipients = [ensure_key_bytes(their_vk)]

        if recipients:
            self.recipients = list(map(ensure_key_bytes, recipients))

        if routing_keys:
            self.routing_keys = list(map(ensure_key_bytes, routing_keys))

    def update(
        self,
        *,
        endpoint: str = None,
        their_vk: Union[bytes, str] = None,
        recipients: Sequence[Union[bytes, str]] = None,
        routing_keys: Sequence[Union[bytes, str]] = None,
        **_kwargs,
    ):
        &#34;&#34;&#34;Update their information.&#34;&#34;&#34;
        if their_vk and recipients:
            raise ValueError(&#34;their_vk and recipients are mutually exclusive.&#34;)

        if endpoint:
            self.endpoint = endpoint

        if their_vk:
            self.recipients = [ensure_key_bytes(their_vk)]

        if recipients:
            self.recipients = list(map(ensure_key_bytes, recipients))

        if routing_keys:
            self.routing_keys = list(map(ensure_key_bytes, routing_keys))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="aries_staticagent.connection.Target.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, *, endpoint: str = None, their_vk: Union[bytes, str] = None, recipients: Sequence[Union[bytes, str]] = None, routing_keys: Sequence[Union[bytes, str]] = None, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update their information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(
    self,
    *,
    endpoint: str = None,
    their_vk: Union[bytes, str] = None,
    recipients: Sequence[Union[bytes, str]] = None,
    routing_keys: Sequence[Union[bytes, str]] = None,
    **_kwargs,
):
    &#34;&#34;&#34;Update their information.&#34;&#34;&#34;
    if their_vk and recipients:
        raise ValueError(&#34;their_vk and recipients are mutually exclusive.&#34;)

    if endpoint:
        self.endpoint = endpoint

    if their_vk:
        self.recipients = [ensure_key_bytes(their_vk)]

    if recipients:
        self.recipients = list(map(ensure_key_bytes, recipients))

    if routing_keys:
        self.routing_keys = list(map(ensure_key_bytes, routing_keys))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aries_staticagent" href="index.html">aries_staticagent</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aries_staticagent.connection.Connection" href="#aries_staticagent.connection.Connection">Connection</a></code></h4>
<ul class="">
<li><code><a title="aries_staticagent.connection.Connection.await_message" href="#aries_staticagent.connection.Connection.await_message">await_message</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.clear_routes" href="#aries_staticagent.connection.Connection.clear_routes">clear_routes</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.dispatch" href="#aries_staticagent.connection.Connection.dispatch">dispatch</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.from_parts" href="#aries_staticagent.connection.Connection.from_parts">from_parts</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.from_seed" href="#aries_staticagent.connection.Connection.from_seed">from_seed</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.handle" href="#aries_staticagent.connection.Connection.handle">handle</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.next" href="#aries_staticagent.connection.Connection.next">next</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.pack" href="#aries_staticagent.connection.Connection.pack">pack</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.random" href="#aries_staticagent.connection.Connection.random">random</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.receiver" href="#aries_staticagent.connection.Connection.receiver">receiver</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.route" href="#aries_staticagent.connection.Connection.route">route</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.route_module" href="#aries_staticagent.connection.Connection.route_module">route_module</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.send" href="#aries_staticagent.connection.Connection.send">send</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.send_and_await_reply" href="#aries_staticagent.connection.Connection.send_and_await_reply">send_and_await_reply</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.send_and_await_reply_async" href="#aries_staticagent.connection.Connection.send_and_await_reply_async">send_and_await_reply_async</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.send_and_await_returned" href="#aries_staticagent.connection.Connection.send_and_await_returned">send_and_await_returned</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.send_and_await_returned_async" href="#aries_staticagent.connection.Connection.send_and_await_returned_async">send_and_await_returned_async</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.send_async" href="#aries_staticagent.connection.Connection.send_async">send_async</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.send_to_session" href="#aries_staticagent.connection.Connection.send_to_session">send_to_session</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.session" href="#aries_staticagent.connection.Connection.session">session</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.session_open" href="#aries_staticagent.connection.Connection.session_open">session_open</a></code></li>
<li><code><a title="aries_staticagent.connection.Connection.unpack" href="#aries_staticagent.connection.Connection.unpack">unpack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aries_staticagent.connection.Keys" href="#aries_staticagent.connection.Keys">Keys</a></code></h4>
<ul class="two-column">
<li><code><a title="aries_staticagent.connection.Keys.Key" href="#aries_staticagent.connection.Keys.Key">Key</a></code></li>
<li><code><a title="aries_staticagent.connection.Keys.Mixin" href="#aries_staticagent.connection.Keys.Mixin">Mixin</a></code></li>
<li><code><a title="aries_staticagent.connection.Keys.did" href="#aries_staticagent.connection.Keys.did">did</a></code></li>
<li><code><a title="aries_staticagent.connection.Keys.sigkey" href="#aries_staticagent.connection.Keys.sigkey">sigkey</a></code></li>
<li><code><a title="aries_staticagent.connection.Keys.verkey" href="#aries_staticagent.connection.Keys.verkey">verkey</a></code></li>
<li><code><a title="aries_staticagent.connection.Keys.verkey_b58" href="#aries_staticagent.connection.Keys.verkey_b58">verkey_b58</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aries_staticagent.connection.MessageDeliveryError" href="#aries_staticagent.connection.MessageDeliveryError">MessageDeliveryError</a></code></h4>
</li>
<li>
<h4><code><a title="aries_staticagent.connection.Session" href="#aries_staticagent.connection.Session">Session</a></code></h4>
<ul class="">
<li><code><a title="aries_staticagent.connection.Session.THREAD_ALL" href="#aries_staticagent.connection.Session.THREAD_ALL">THREAD_ALL</a></code></li>
<li><code><a title="aries_staticagent.connection.Session.handle" href="#aries_staticagent.connection.Session.handle">handle</a></code></li>
<li><code><a title="aries_staticagent.connection.Session.send" href="#aries_staticagent.connection.Session.send">send</a></code></li>
<li><code><a title="aries_staticagent.connection.Session.session_id" href="#aries_staticagent.connection.Session.session_id">session_id</a></code></li>
<li><code><a title="aries_staticagent.connection.Session.should_return_route" href="#aries_staticagent.connection.Session.should_return_route">should_return_route</a></code></li>
<li><code><a title="aries_staticagent.connection.Session.thread" href="#aries_staticagent.connection.Session.thread">thread</a></code></li>
<li><code><a title="aries_staticagent.connection.Session.thread_all" href="#aries_staticagent.connection.Session.thread_all">thread_all</a></code></li>
<li><code><a title="aries_staticagent.connection.Session.update_thread_from_msg" href="#aries_staticagent.connection.Session.update_thread_from_msg">update_thread_from_msg</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aries_staticagent.connection.Target" href="#aries_staticagent.connection.Target">Target</a></code></h4>
<ul class="">
<li><code><a title="aries_staticagent.connection.Target.update" href="#aries_staticagent.connection.Target.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>