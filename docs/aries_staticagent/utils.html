<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>aries_staticagent.utils API documentation</title>
<meta name="description" content="General utils" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aries_staticagent.utils</code></h1>
</header>
<section id="section-intro">
<p>General utils</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; General utils &#34;&#34;&#34;
from functools import wraps
from typing import Union, Optional, Callable
import copy
import datetime

import aiohttp

from . import crypto
from .message import Message
from .mtc import (
    Context as MTCContext,
    NONE as NoMTCContext,
    AUTHCRYPT_AFFIRMED,
    AUTHCRYPT_DENIED,
    ANONCRYPT_AFFIRMED,
    ANONCRYPT_DENIED
)


def timestamp():
    &#34;&#34;&#34; return a timestamp. &#34;&#34;&#34;
    return datetime.datetime.utcnow().replace(
        tzinfo=datetime.timezone.utc
    ).isoformat(&#39; &#39;)


def ensure_key_bytes(key: Union[bytes, str]):
    &#34;&#34;&#34;Ensure key is formatted as bytes.&#34;&#34;&#34;
    if isinstance(key, bytes):
        return key
    if isinstance(key, str):
        return crypto.b58_to_bytes(key)

    raise TypeError(&#39;key must be bytes or str&#39;)


def ensure_key_b58(key: Union[bytes, str]):
    &#34;&#34;&#34;Ensure key is formatted as b58 string.&#34;&#34;&#34;
    if isinstance(key, bytes):
        return crypto.bytes_to_b58(key)
    if isinstance(key, str):
        return key

    raise TypeError(&#39;key must be bytes or str&#39;)


FORWARD = &#39;https://didcomm.org/routing/1.0/forward&#39;


def forward_msg(to: Union[bytes, str], msg: dict):
    &#34;&#34;&#34;Return a forward message.&#34;&#34;&#34;
    return Message({
        &#39;@type&#39;: FORWARD,
        &#39;to&#39;: ensure_key_b58(to),
        &#39;msg&#39;: msg
    })


def find_message_in_args(args):
    &#34;&#34;&#34;Helper for picking out message from handler arguments.&#34;&#34;&#34;
    for index, arg in enumerate(args):
        if isinstance(arg, Message):
            return arg, index
    return None


def preprocess(preprocessor: Callable):
    &#34;&#34;&#34;Preprocess a message before handling.

    This facility might be used to validate and unpack signatures/attachments,
    validate timing or ordering, add data to the message object (i.e. append
    protocol state information), etc.

    A deep copy of the original message is given to preprocessors to prevent
    accidental manipulation. Preprocessors must return the altered message
    object if modification is intended. Preprocessors should raise an error if
    preprocessing fails.
    &#34;&#34;&#34;
    def _preprocess_decorated(func):
        @wraps(func)
        def _wrapped(*args, **kwargs):
            msg, index = find_message_in_args(args)
            preprocessed = preprocessor(copy.deepcopy(msg))

            if preprocessed:
                args = list(args)
                args[index] = preprocessed

            return func(*args, **kwargs)
        return _wrapped
    return _preprocess_decorated


def preprocess_async(preprocessor: Callable):
    &#34;&#34;&#34;Asynchronously preprocess a message before handling.

    This follows has the same semantics as `preprocess`, just with an async
    preprocessor.
    &#34;&#34;&#34;
    def _preprocess_decorated(func):
        @wraps(func)
        async def _wrapped(*args, **kwargs):
            msg, index = find_message_in_args(args)
            preprocessed = await preprocessor(copy.deepcopy(msg))

            if preprocessed:
                args = list(args)
                args[index] = preprocessed

            return await func(*args, **kwargs)
        return _wrapped
    return _preprocess_decorated


class InsufficientMessageTrust(Exception):
    &#34;&#34;&#34;When a message does not meet the MTC requirements.&#34;&#34;&#34;


def mtc(
        affirmed: MTCContext = NoMTCContext,
        denied: MTCContext = NoMTCContext
):
    &#34;&#34;&#34;
    Validate that the message passed to this handler has the expected trust
    context.
    &#34;&#34;&#34;
    def _mtc_preprocessor(msg):
        if msg.mtc.affirmed != affirmed:
            raise InsufficientMessageTrust(
                f&#39;Actual affirmed {msg.mtc.affirmed} does not match &#39;
                f&#39;expected affirmed of {affirmed}&#39;
            )
        if msg.mtc.denied != denied:
            raise InsufficientMessageTrust(
                f&#39;Actual denied {msg.mtc.denied} does not match expected &#39;
                f&#39;denied of {denied}&#39;
            )
    return preprocess(_mtc_preprocessor)


def authcrypted(func):
    &#34;&#34;&#34;Validate that the message passed to this handler is authcrypted.&#34;&#34;&#34;
    return mtc(AUTHCRYPT_AFFIRMED, AUTHCRYPT_DENIED)(func)


def anoncrypted(func):
    &#34;&#34;&#34;Validate that the message passed to this handler is anoncrypted.&#34;&#34;&#34;
    return mtc(ANONCRYPT_AFFIRMED, ANONCRYPT_DENIED)(func)


class MessageValidationError(Exception):
    &#34;&#34;&#34;When message validation fails.&#34;&#34;&#34;


def validate(validator: Callable, *, coerce: Optional[Callable] = None):
    &#34;&#34;&#34;Validate the message passed to this handler using validator.

    A deep copy of the original message is given to validators to prevent
    accidental manipulation. Validators must return the altered message
    object if modification is intended. Validators should raise an error if
    validation fails.

    Args:
        coerce (Callable): Optionally coerce the value before validation.
    &#34;&#34;&#34;
    def _validate_preprocessor(msg):
        to_be_validated = msg
        if coerce:
            to_be_validated = coerce(to_be_validated)

        try:
            return validator(to_be_validated)
        except Exception as err:
            raise MessageValidationError(
                &#39;Message failed to validate&#39;
            ) from err

    return preprocess(_validate_preprocessor)


async def http_send(msg: bytes, endpoint: str) -&gt; Optional[bytes]:
    &#34;&#34;&#34;Send over HTTP.&#34;&#34;&#34;
    async with aiohttp.ClientSession() as session:
        headers = {&#39;content-type&#39;: &#39;application/ssi-agent-wire&#39;}
        async with session.post(
                endpoint,
                data=msg,
                headers=headers) as resp:

            body = await resp.read()
            if resp.status != 200 and resp.status != 202:
                raise Exception(
                    &#39;Error while sending message: {}&#39;.format(
                        resp.status
                    )
                )
            if resp.status == 200 and body:
                return body

    return None


# TODO: Persist websocket until return_route = None sent
async def ws_send(msg: bytes, endpoint: str) -&gt; Optional[bytes]:
    &#34;&#34;&#34;Send over WS.

    This send method is experimental and should not be used for more than
    experimenting. This method is very inefficient as it throws out the created
    websocket after receiving only a single msg.
    &#34;&#34;&#34;
    async with aiohttp.ClientSession() as session:
        async with session.ws_connect(endpoint) as sock:
            await sock.send_bytes(msg)
            async for msg in sock:
                if msg.type == aiohttp.WSMsgType.BINARY:
                    return msg.data

                if msg.type == aiohttp.WSMsgType.ERROR:
                    raise Exception(
                        &#39;ws connection closed with exception %s&#39; %
                        sock.exception()
                    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="aries_staticagent.utils.anoncrypted"><code class="name flex">
<span>def <span class="ident">anoncrypted</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate that the message passed to this handler is anoncrypted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def anoncrypted(func):
    &#34;&#34;&#34;Validate that the message passed to this handler is anoncrypted.&#34;&#34;&#34;
    return mtc(ANONCRYPT_AFFIRMED, ANONCRYPT_DENIED)(func)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.utils.authcrypted"><code class="name flex">
<span>def <span class="ident">authcrypted</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate that the message passed to this handler is authcrypted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authcrypted(func):
    &#34;&#34;&#34;Validate that the message passed to this handler is authcrypted.&#34;&#34;&#34;
    return mtc(AUTHCRYPT_AFFIRMED, AUTHCRYPT_DENIED)(func)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.utils.ensure_key_b58"><code class="name flex">
<span>def <span class="ident">ensure_key_b58</span></span>(<span>key: Union[bytes, str])</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure key is formatted as b58 string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_key_b58(key: Union[bytes, str]):
    &#34;&#34;&#34;Ensure key is formatted as b58 string.&#34;&#34;&#34;
    if isinstance(key, bytes):
        return crypto.bytes_to_b58(key)
    if isinstance(key, str):
        return key

    raise TypeError(&#39;key must be bytes or str&#39;)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.utils.ensure_key_bytes"><code class="name flex">
<span>def <span class="ident">ensure_key_bytes</span></span>(<span>key: Union[bytes, str])</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure key is formatted as bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_key_bytes(key: Union[bytes, str]):
    &#34;&#34;&#34;Ensure key is formatted as bytes.&#34;&#34;&#34;
    if isinstance(key, bytes):
        return key
    if isinstance(key, str):
        return crypto.b58_to_bytes(key)

    raise TypeError(&#39;key must be bytes or str&#39;)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.utils.find_message_in_args"><code class="name flex">
<span>def <span class="ident">find_message_in_args</span></span>(<span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper for picking out message from handler arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_message_in_args(args):
    &#34;&#34;&#34;Helper for picking out message from handler arguments.&#34;&#34;&#34;
    for index, arg in enumerate(args):
        if isinstance(arg, Message):
            return arg, index
    return None</code></pre>
</details>
</dd>
<dt id="aries_staticagent.utils.forward_msg"><code class="name flex">
<span>def <span class="ident">forward_msg</span></span>(<span>to: Union[bytes, str], msg: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a forward message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward_msg(to: Union[bytes, str], msg: dict):
    &#34;&#34;&#34;Return a forward message.&#34;&#34;&#34;
    return Message({
        &#39;@type&#39;: FORWARD,
        &#39;to&#39;: ensure_key_b58(to),
        &#39;msg&#39;: msg
    })</code></pre>
</details>
</dd>
<dt id="aries_staticagent.utils.http_send"><code class="name flex">
<span>async def <span class="ident">http_send</span></span>(<span>msg: bytes, endpoint: str) ‑> Union[bytes, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Send over HTTP.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def http_send(msg: bytes, endpoint: str) -&gt; Optional[bytes]:
    &#34;&#34;&#34;Send over HTTP.&#34;&#34;&#34;
    async with aiohttp.ClientSession() as session:
        headers = {&#39;content-type&#39;: &#39;application/ssi-agent-wire&#39;}
        async with session.post(
                endpoint,
                data=msg,
                headers=headers) as resp:

            body = await resp.read()
            if resp.status != 200 and resp.status != 202:
                raise Exception(
                    &#39;Error while sending message: {}&#39;.format(
                        resp.status
                    )
                )
            if resp.status == 200 and body:
                return body

    return None</code></pre>
</details>
</dd>
<dt id="aries_staticagent.utils.mtc"><code class="name flex">
<span>def <span class="ident">mtc</span></span>(<span>affirmed: <a title="aries_staticagent.mtc.Context" href="mtc.html#aries_staticagent.mtc.Context">Context</a> = Context.NONE, denied: <a title="aries_staticagent.mtc.Context" href="mtc.html#aries_staticagent.mtc.Context">Context</a> = Context.NONE)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate that the message passed to this handler has the expected trust
context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mtc(
        affirmed: MTCContext = NoMTCContext,
        denied: MTCContext = NoMTCContext
):
    &#34;&#34;&#34;
    Validate that the message passed to this handler has the expected trust
    context.
    &#34;&#34;&#34;
    def _mtc_preprocessor(msg):
        if msg.mtc.affirmed != affirmed:
            raise InsufficientMessageTrust(
                f&#39;Actual affirmed {msg.mtc.affirmed} does not match &#39;
                f&#39;expected affirmed of {affirmed}&#39;
            )
        if msg.mtc.denied != denied:
            raise InsufficientMessageTrust(
                f&#39;Actual denied {msg.mtc.denied} does not match expected &#39;
                f&#39;denied of {denied}&#39;
            )
    return preprocess(_mtc_preprocessor)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.utils.preprocess"><code class="name flex">
<span>def <span class="ident">preprocess</span></span>(<span>preprocessor: Callable)</span>
</code></dt>
<dd>
<div class="desc"><p>Preprocess a message before handling.</p>
<p>This facility might be used to validate and unpack signatures/attachments,
validate timing or ordering, add data to the message object (i.e. append
protocol state information), etc.</p>
<p>A deep copy of the original message is given to preprocessors to prevent
accidental manipulation. Preprocessors must return the altered message
object if modification is intended. Preprocessors should raise an error if
preprocessing fails.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess(preprocessor: Callable):
    &#34;&#34;&#34;Preprocess a message before handling.

    This facility might be used to validate and unpack signatures/attachments,
    validate timing or ordering, add data to the message object (i.e. append
    protocol state information), etc.

    A deep copy of the original message is given to preprocessors to prevent
    accidental manipulation. Preprocessors must return the altered message
    object if modification is intended. Preprocessors should raise an error if
    preprocessing fails.
    &#34;&#34;&#34;
    def _preprocess_decorated(func):
        @wraps(func)
        def _wrapped(*args, **kwargs):
            msg, index = find_message_in_args(args)
            preprocessed = preprocessor(copy.deepcopy(msg))

            if preprocessed:
                args = list(args)
                args[index] = preprocessed

            return func(*args, **kwargs)
        return _wrapped
    return _preprocess_decorated</code></pre>
</details>
</dd>
<dt id="aries_staticagent.utils.preprocess_async"><code class="name flex">
<span>def <span class="ident">preprocess_async</span></span>(<span>preprocessor: Callable)</span>
</code></dt>
<dd>
<div class="desc"><p>Asynchronously preprocess a message before handling.</p>
<p>This follows has the same semantics as <code><a title="aries_staticagent.utils.preprocess" href="#aries_staticagent.utils.preprocess">preprocess()</a></code>, just with an async
preprocessor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess_async(preprocessor: Callable):
    &#34;&#34;&#34;Asynchronously preprocess a message before handling.

    This follows has the same semantics as `preprocess`, just with an async
    preprocessor.
    &#34;&#34;&#34;
    def _preprocess_decorated(func):
        @wraps(func)
        async def _wrapped(*args, **kwargs):
            msg, index = find_message_in_args(args)
            preprocessed = await preprocessor(copy.deepcopy(msg))

            if preprocessed:
                args = list(args)
                args[index] = preprocessed

            return await func(*args, **kwargs)
        return _wrapped
    return _preprocess_decorated</code></pre>
</details>
</dd>
<dt id="aries_staticagent.utils.timestamp"><code class="name flex">
<span>def <span class="ident">timestamp</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>return a timestamp.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timestamp():
    &#34;&#34;&#34; return a timestamp. &#34;&#34;&#34;
    return datetime.datetime.utcnow().replace(
        tzinfo=datetime.timezone.utc
    ).isoformat(&#39; &#39;)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.utils.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>validator: Callable, *, coerce: Union[Callable, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the message passed to this handler using validator.</p>
<p>A deep copy of the original message is given to validators to prevent
accidental manipulation. Validators must return the altered message
object if modification is intended. Validators should raise an error if
validation fails.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coerce</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Optionally coerce the value before validation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(validator: Callable, *, coerce: Optional[Callable] = None):
    &#34;&#34;&#34;Validate the message passed to this handler using validator.

    A deep copy of the original message is given to validators to prevent
    accidental manipulation. Validators must return the altered message
    object if modification is intended. Validators should raise an error if
    validation fails.

    Args:
        coerce (Callable): Optionally coerce the value before validation.
    &#34;&#34;&#34;
    def _validate_preprocessor(msg):
        to_be_validated = msg
        if coerce:
            to_be_validated = coerce(to_be_validated)

        try:
            return validator(to_be_validated)
        except Exception as err:
            raise MessageValidationError(
                &#39;Message failed to validate&#39;
            ) from err

    return preprocess(_validate_preprocessor)</code></pre>
</details>
</dd>
<dt id="aries_staticagent.utils.ws_send"><code class="name flex">
<span>async def <span class="ident">ws_send</span></span>(<span>msg: bytes, endpoint: str) ‑> Union[bytes, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Send over WS.</p>
<p>This send method is experimental and should not be used for more than
experimenting. This method is very inefficient as it throws out the created
websocket after receiving only a single msg.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def ws_send(msg: bytes, endpoint: str) -&gt; Optional[bytes]:
    &#34;&#34;&#34;Send over WS.

    This send method is experimental and should not be used for more than
    experimenting. This method is very inefficient as it throws out the created
    websocket after receiving only a single msg.
    &#34;&#34;&#34;
    async with aiohttp.ClientSession() as session:
        async with session.ws_connect(endpoint) as sock:
            await sock.send_bytes(msg)
            async for msg in sock:
                if msg.type == aiohttp.WSMsgType.BINARY:
                    return msg.data

                if msg.type == aiohttp.WSMsgType.ERROR:
                    raise Exception(
                        &#39;ws connection closed with exception %s&#39; %
                        sock.exception()
                    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aries_staticagent.utils.InsufficientMessageTrust"><code class="flex name class">
<span>class <span class="ident">InsufficientMessageTrust</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>When a message does not meet the MTC requirements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InsufficientMessageTrust(Exception):
    &#34;&#34;&#34;When a message does not meet the MTC requirements.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="aries_staticagent.utils.MessageValidationError"><code class="flex name class">
<span>class <span class="ident">MessageValidationError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>When message validation fails.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MessageValidationError(Exception):
    &#34;&#34;&#34;When message validation fails.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aries_staticagent" href="index.html">aries_staticagent</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="aries_staticagent.utils.anoncrypted" href="#aries_staticagent.utils.anoncrypted">anoncrypted</a></code></li>
<li><code><a title="aries_staticagent.utils.authcrypted" href="#aries_staticagent.utils.authcrypted">authcrypted</a></code></li>
<li><code><a title="aries_staticagent.utils.ensure_key_b58" href="#aries_staticagent.utils.ensure_key_b58">ensure_key_b58</a></code></li>
<li><code><a title="aries_staticagent.utils.ensure_key_bytes" href="#aries_staticagent.utils.ensure_key_bytes">ensure_key_bytes</a></code></li>
<li><code><a title="aries_staticagent.utils.find_message_in_args" href="#aries_staticagent.utils.find_message_in_args">find_message_in_args</a></code></li>
<li><code><a title="aries_staticagent.utils.forward_msg" href="#aries_staticagent.utils.forward_msg">forward_msg</a></code></li>
<li><code><a title="aries_staticagent.utils.http_send" href="#aries_staticagent.utils.http_send">http_send</a></code></li>
<li><code><a title="aries_staticagent.utils.mtc" href="#aries_staticagent.utils.mtc">mtc</a></code></li>
<li><code><a title="aries_staticagent.utils.preprocess" href="#aries_staticagent.utils.preprocess">preprocess</a></code></li>
<li><code><a title="aries_staticagent.utils.preprocess_async" href="#aries_staticagent.utils.preprocess_async">preprocess_async</a></code></li>
<li><code><a title="aries_staticagent.utils.timestamp" href="#aries_staticagent.utils.timestamp">timestamp</a></code></li>
<li><code><a title="aries_staticagent.utils.validate" href="#aries_staticagent.utils.validate">validate</a></code></li>
<li><code><a title="aries_staticagent.utils.ws_send" href="#aries_staticagent.utils.ws_send">ws_send</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aries_staticagent.utils.InsufficientMessageTrust" href="#aries_staticagent.utils.InsufficientMessageTrust">InsufficientMessageTrust</a></code></h4>
</li>
<li>
<h4><code><a title="aries_staticagent.utils.MessageValidationError" href="#aries_staticagent.utils.MessageValidationError">MessageValidationError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>